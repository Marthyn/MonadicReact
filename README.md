# Introduction
This project makes it easier to create, compose, and re-use React controllers and containers without losing type safety, even when routing.

It does so by defining a monadic interface around React components. This interface is then used to support construction of a series of useful combinators. The library is written in TypeScript, and is provided with definition files: it can be used from both plain JavaScript and TypeScript.


## Installation
Installation is the usual `npm install monadic_react`.

## Sample usage
To use the application, create one or more components of type `C<void>`, for example:

```
let my_component : C<void> =
  string("view")("Hello world of monads!").ignore()
```

The component is then wrapped in a page for the router. Let us keep things easy and define a route which matches everything:

```
let menu_page = () : Route<{}> => ({
  url: fallback_url(),
  page: (_:{}) => my_component
})
```

The component can then be instantiated by invoking the application constructor and router:

```
<div className="component">
  {
    application("edit", window.location.href, "", Immutable.List<Route<{}>>([main_page()])))
  }
</div>
```

By working on the definition of `my_component` it is possible to create much more complex applications. For example, let us
chain two components together:

```
let my_component : C<void> =
multi_selector<number>("checkbox",x => x.toString())([1, 3, 5]).bind(`multi_selector`, n =>
  string("view")(JSON.stringify(n.toArray())).ignore())
```

In the sample above we have used the `bind` operator in order to feed the output of the multi-selector in the string renderer.

## React monad
The react monad is based on the simple idea that a non-trivial react component will eventually produce data, which is usually fed into another component.

By focusing on the flow of data generated by react components, instead of what they do on the page and how they are rendered, we focus on how components are connected together in a large network of related functionality. This removes the need for a lot of glue code which just passes information around, while preserving useful properties such as referential transparency (components can be designed fully stateless now), and type safety (components have clearly defined and typed boundaries).

For example, the `string` component will produce a string which will be fed into another component, for example a component which assembles data from various input components for later upload.

### Introduction to monads
Monads are a powerful construct tying together mathematics and informatics in an elegant way. The appeal of the highest mathematics, and the clear and useful applicability, have made monads alluring for many developers. Indeed, monads are found in, among others:
- `Promise` in the JavaScript world;
- `flatMap` in the Immutablejs library;
- `LINQ` in C#;
- the Haskell standard library;

and more. Moreover, countless tutorials are found online where people who already found out about this elegant and powerful concept try to share it with others.

At its core, a monad is a generic type `M`, that is `M` was defined along the lines of:

```type M<A> = ...```

When we define a monad in terms of `M`, then it means that we want to be able to instantiate, and use, instances of `M` without having to know anything about its structure.

The simplest operation that we need to be able to perform is creating instances of `M`. This is done with the `unit` operator, which creates an instance of `M<A>` around a value of type `A`, no matter what type `A` actually was:

`unit : A => M<A>`

Given an `M<A>`, we then want to be able to compose it with other instances of `M<B>` which are dependent of it. This dependency is expressed by saying that, in order to get to the instance of `M<B>` that we wish to obtain, we need a value of type `A` which will somehow come out of `M<A>`:

`bind : M<A> => (A => M<B>) => M<B>`

After having defined `unit` and `bind`, which are the bare minimum needed in order to be able to have a working monad, we can start thinking in terms of usability of our monad as a library. This usually leads to an "onion" design, with a basic core, surrounded by primitives, surrounded by combinators, templates, etc. As long as primitives, combinators, and templates all yield instances of `M`, they will still be valid input for further binding or applying the other combinators yet again. This is the fundamental principle of composability: a library should make it possible to keep nesting constructs inside each other in order to be flexible and not artificially constraining.

It is useful for some to first learn monads in terms of simple, concrete containers such as `Option` or `List`, and then move on to the more abstract ones such as the present implementation.

### Core
The core of the library, found in file `core.tsx`, contains the definition of the monad itself, `C<A>`. An instance of the monad is a function which takes as input a callback to signify completion, a continuation which will accept a value of type `A` (the data produced by the component, from now on called **output** of the component); finally, the monad returns a `JSX.Element`, which is the actually renderable component:

```
type Cont<A> = (callback:() => void) => (_:A) => void
type C<A> = {
  comp:(ctxt:() => Context) => (cont:Cont<A>) => JSX.Element
  ...
}
```

Using the library does not require interacting with this data type directly: that is done by invoking functions `unit` and `bind`:

```
unit = function<A>(x:A, key?:string, dbg?:() => string) : C<A> = ...

bind = function<A,B>(key:string, p:C<A>, k:((_:A)=>C<B>), className?:string, dbg?:() => string) : C<B> = ...
```

Notice that, in contrast with the definitions of `unit` and `bind` given above, we have some more parameters: since react expects a `key` in order to accelerate the reconciliation process, all generated components may specify an (optional) key. `bind` will still work if the key is passed as `undefined`, even though it is not always ideal.

Of course, we can also perform basic transformations on components' data, for example by applying a given transformation function to each output of an existing component. This effectively turns a component of type `C<A>` in a (related) component of type `C<B>`, as long as we provide a function `f:A=>B`:

```
let map: <A, B>(key?: string, dbg?: () => string) => (f: (_: A) => B) => (_: C<A>) => C<B>;
```

Similarly, we can restrict the output of an existing component. This effectively turns a component of type `C<A>` in a (related) component of type `C<A>` which outputs slightly less values of type `A`, as long as we provide a predicate `p:A=>boolean`:

```
filter: <A>(key?: string, dbg?: () => string) => (p: (_: A) => boolean) => (_: C<A>) => C<A>;
```

Note that, given an instance `p:C<A>`, we can directly call some methods on it such as: `p.bind(...)`, `p.ignore()`, `p.never<B>()` instead of having to invoke `bind(p, ...)`.

### Primitives
Having defined the core operators is just the first step. To be able to do anything actually useful on a webpage, we have defined a series of primitives which encapsulate common HTML constructs as instances of our monad. Each primitive accepts as input the `mode` (`"view" | "edit"`) in order to instantiate the component as editable or just to show its contents.

The primitive then returns a function with, as input, the initial value of the type it manipulates (let's call it `P`) and gives as output a component of that type (that would be `C<P>`).

For example, the `number` primitive, after we have given the `mode` (and optionally the `key`), results in a function `number => C<number>`:

```
number: (mode: Mode, key?: string, dbg?: () => string) => (value: number) => C<number>;
```

The `string` primitive, after we have given the `mode` (and optionally the `key`), results in a function `string => C<string>`:

```
string: (mode: Mode, type?: StringType, key?: string, dbg?: () => string) => (value: string) => C<string>;
```

And so on. There are further primitives for `bool` (`bool => C<bool>`), `date`, `time`, and `date_time` (all three `Moment.Moment) => C<Moment.Moment>`).

### Html
The subsequent layer contains some slightly more articulated html constructs such as labels, divs, buttons, selectors, and more. The basic components just add some tags to the page around, before, or after the html produced by another component. These constructs, which can be seen as **decorators** (or natural transformations if you are categorically inclined) take as input some basic configuration that describe the sort of decoration operation to perform, followed by the function to decorate. The function to decorate always has signature `A => C<B>`. The decorator then returns a result with the same signature, that is `A => C<B>`:

```
label<A, B>(text: string, span_before_content?: boolean, className?: string, key?: string, dbg?: () => string): (p: (_: A) => C<B>) => ((_: A) => C<B>)
h1<A, B>(text: string, className?: string, key?: string, dbg?: () => string): (p: (_: A) => C<B>) => ((_: A) => C<B>)
h2<A, B>(text: string, className?: string, key?: string, dbg?: () => string): (p: (_: A) => C<B>) => ((_: A) => C<B>)
div<A, B>(className?: string, key?: string, dbg?: () => string): (ps: Array<(_: A) => C<void>>) => (p: (_: A) => C<B>) => ((_: A) => C<B>)
overlay<A, B>(key?: string, dbg?: () => string): (ps: Array<(_: A) => C<void>>) => (p: (_: A) => C<B>) => ((_: A) => C<B>)
form<A, B>(className?: string, key?: string, dbg?: () => string): (p: (_: A) => C<B>) => ((_: A) => C<B>)
```

Buttons (and anchors) are slightly simpler in signature. The button, after receiving the configuration parameters, returns a function `A => C<A>`. This function is "interrupted" by the button: before the returned component `C<A>` will return the value of `A` that came in as input, the button must be clicked:

```
button: <A>(label: string, disabled?: boolean, key?: string, className?: string, dbg?: () => string) => (x: A) => C<A>
a: <A>(label: string, disabled?: boolean, key?: string, className?: string, dbg?: () => string) => (x: A) => C<A>
```

Other html components perform an own function. The selectors take as input the candidate items for selection, a `to_string` function which tells how to draw a selectable item, and return the selected item(s):

```
selector: <A>(type: SelectorType, to_string: (_: A) => string, key?: string, dbg?: () => string) => (items: Array<A>, selected_item?: A) => C<A>
multi_selector: <A>(type: MultiSelectorType, to_string: (_: A) => string, key?: string, dbg?: () => string) => (items: Array<A>, selected_items?: Array<A>) => C<Array<A>>
```

Finally, some html components allow the manipulation of links, files, and images (in base64).

```
image: (mode: Mode, key?: string, dbg?: () => string) => (src: string) => C<string>
link: <A>(label: string, url: string, disabled?: boolean, key?: string, dbg?: () => string) => C<void>
file: <A>(mode: Mode, label: string, url: string, disabled?: boolean, key?: string, dbg?: () => string) => C<File>
```

A special mention goes to the *rich text* component, which takes as input a string containing the (serialized) json input needed by a DraftJs rich text editor:

```
rich_text(json_state: string, mode: Mode, key?: string, dbg?: () => string): C<string>
```

### Combinators
Combinators are the next step in the abstraction chain (the next layer in the onion). Combinators are abstract transformers which take as input one or more (functions of) components and yield new (functions of) components.

The simplest combinator is `repeat`. `repeat` takes as input a function `p:A => C<A>`, and returns as output a function `A => C<A>`. The returned function, whenever it receives and input of type `A`, passes it through to `p`. The output of `p` is then given as output of the returned function. The output of `p` is also fed back into `p` itself (which should be smart enough to see that the input is the same, and therefore not yield another output right away):

```
repeat: <A>(key?: string, dbg?: () => string) => (p: (_: A) => C<A>) => (_: A) => C<A>;
```

`repeat` by itself is not very useful. When it really shines is in combination with `any`. `any` accepts as input an array of functions `ps:(A => C<B>)`, and returns as output a single function `A => C<B>`. The returned function passes its own input (`A`) to each function in `ps`. The first of the resulting components that yields a `B` as output gets its output forwarded as the output of `any`:

```
any: <A, B>(key?: string, className?: string, dbg?: () => string) => (ps: ((_: A) => C<B>)[]) => (_: A) => C<B>;
```

Sometimes we need to perform a conversion from a complex datatype (say `A`) into a simpler (say `B`). Suppose we have a series of conversion functions:
- `inb:A => B` to convert an `A` to a `B`;
- `out:A => B => A` to convert the original `A` and a new value of `B` back into `B`.

Then we can convert a function `p:B =>  C<B>` into `A => C<A>`:

```
retract: <A, B>(key?: string, dbg?: () => string) => (inb: (_: A) => B, out: (_: A) => (_: B) => A, p: (_: B) => C<B>) => (_: A) => C<A>;
```

As an example of a retraction, consider:

```
type Person = { Name:string, Surname:string }

let person_name : (_:Person) => C<Person> = p =>
  retract<Person>()(p => p.Name, p => n => ({...p, Name:n}), string("view"))
```

When combined with `repeat` and `any`, then we get a form:

```
let person_form =
  repeat<Person>("state_repeater")(
    any<Person>("field_selector")([
      person_name,
      person_surname
    ])
  ).bind("person_form", p =>
  ...do something with p...)
```

`all`, similarly to `any`, gets as input an array of components and, when all components have yielded an output, all the outputs are passed through:

```
all: <A>(ps: C<A>[], key?: string, dbg?: () => string) => C<A[]>;
```

We can turn a `Promise` into a component by "lifting" it:

```
lift_promise: <A, B>(p: (_: A) => Promise<B>, retry_strategy: RetryStrategy, key?: string, dbg?: () => string) => (_: A) => C<B>;
```

Finally, given a component `p:C<A>`, we can turn into a silent component of type `C<B>` (that is, a component which will never output a value of type `B`) by applying `never` to it:

```
never: <A, B>(p: C<A>, key?: string) => C<B>;
```

### Routing
The library comes with routing included. The function `application`, which instantiates a component, accepts as input a list of routes.

Routes are composed of an `url` and a `page`. The `url` is created by invoking `make_url` on an array of url elements:

```
make_url: <T, K extends keyof T>(template: UrlElement<K>[]) => PartialRetraction<string, T>
```

For example, we could invoke `make_url` as:
- `make_url<{}, never>(["about"])`, which parses url `/about`;
- `make_url<{}, never>(["info"])`, which parses url `/info`;
- `make_url<{}, never>(["info", "team"])`, which parses url `/info/team`.

Parsing an url might also yield some data which has been extracted from the url itself, such as an id. In this case, we must define a data structure to be extracted from the url, and then construct the template so that the proper fields are identified:

```
type Id = { id:number }
make_url<Id, "id">(["customer", { kind:"int", name:"id" }])
```

Note that the above is typesafe. Invalid variations will give a compiler error, for example:
- `make_url<Id, "xxx">(["customer", { kind:"int", name:"id" }])` will complain that `xxx` is not a field of `Id`;
- `make_url<Id, "id">(["customer", { kind:"int", name:"zzz" }])` will complain that `zzz` is not a field of `Id`.


As we have assembled an url which yields a value of type `T`, we can define the page as a function `T => C<void>`. Of course, if parsing has failed and we could not extract a value of type `T` from the url, then we cannot invoke the function and instantiate the page:

```
let about : Route<{}> = {
  url: make_url<{}, never>(["about"]),
  page: _ => ... definition of about page ...
}
```

`about` as defined above can be used as an entry in the list of routes that are given to the `application` function. Notice that `application` also accepts a `base_url`, which will be kept intact, and the current `slug`, which is used as input for the router.

A component can also set its own url. This is simply achieved by getting the context and then invoking its method `set_url` with a url payload (in the sample below assume variable `t:T` and `K` keys of `T`):

```
get_context().bind(s.description, c =>
c.set_url(t, make_url<T, K>([...url elements...])).bind(
...)
```

Note that a special url is `fallback_url`, which matches any url. It is usually used for handling errors or making sure that the homepage is accessible even if the address has been wrongly typed.

### Templates
Based on the functionality that we have set up so far, it becomes possible to define templates. Templates can

#### Menu template
Todo

#### Form templates
Todo

#### Workflow template
Todo

### Injecting custom react components
Todo

### Advanced
Todo

#### Building your own templates
Todo

#### Building your own combinators
Todo

# Samples
Todo

# About the authors
This library has mostly been set up by Dr. Giuseppe Maggiore, and is to some extent inspired from his PhD thesis on monadic coroutines for game development.

Giuseppe works as CTO for Hoppinger BV, a company focusing on web strategy, design, and development in Rotterdam (Netherlands). Hoppinger supports the development of the library with significant internal effort, and acts as beta user and corporate sponsor as part of its innovation efforts.
