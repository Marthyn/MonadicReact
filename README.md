# Introduction
This project makes it easier to create, compose, and re-use React controllers and containers without losing type safety, even when routing.

It does so by defining a monadic interface around React components. This interface is then used to support construction of a series of useful combinators. The library is written in TypeScript, and is provided with definition files: it can be used from both plain JavaScript and TypeScript.


## Installation
Installation is the usual `npm install monadic_react`.

## Sample usage
To use the application, create one or more components of type `C<void>`, for example:

```
let my_component : C<void> =
  string("view")("Hello world of monads!").ignore()
```

The component is then wrapped in a page for the router. Let us keep things easy and define a route which matches everything:

```
let menu_page = () : Route<{}> => ({
  url: fallback_url(),
  page: (_:{}) => my_component
})
```

The component can then be instantiated by invoking the application constructor and router:

```
<div className="component">
  {
    application("edit", window.location.href, "", Immutable.List<Route<{}>>([main_page()])))
  }
</div>
```

By working on the definition of `my_component` it is possible to create much more complex applications. For example, let us
chain two components together:

```
let my_component : C<void> =
multi_selector<number>("checkbox",x => x.toString())([1, 3, 5]).bind(`multi_selector`, n =>
  string("view")(JSON.stringify(n.toArray())).ignore())
```

In the sample above we have used the `bind` operator in order to feed the output of the multi-selector in the string renderer.

## React monad
The react monad is based on the simple idea that a non-trivial react component will eventually produce data, which is usually fed into another component.

By focusing on the flow of data generated by react components, instead of what they do on the page and how they are rendered, we focus on how components are connected together in a large network of related functionality. This removes the need for a lot of glue code which just passes information around, while preserving useful properties such as referential transparency (components can be designed fully stateless now), and type safety (components have clearly defined and typed boundaries).

For example, the `string` component will produce a string which will be fed into another component, for example a component which assembles data from various input components for later upload.

### Introduction to monads
Monads are a powerful construct tying together mathematics and informatics in an elegant way. The appeal of the highest mathematics, and the clear and useful applicability, have made monads alluring for many developers. Indeed, monads are found in, among others:
- `Promise` in the JavaScript world;
- `flatMap` in the Immutablejs library;
- `LINQ` in C#;
- the Haskell standard library;

and more. Moreover, countless tutorials are found online where people who already found out about this elegant and powerful concept try to share it with others.

At its core, a monad is a generic type `M`, that is `M` was defined along the lines of:

```type M<A> = ...```

When we define a monad in terms of `M`, then it means that we want to be able to instantiate, and use, instances of `M` without having to know anything about its structure.

The simplest operation that we need to be able to perform is creating instances of `M`. This is done with the `unit` operator, which creates an instance of `M<A>` around a value of type `A`, no matter what type `A` actually was:

`unit : A => M<A>`

Given an `M<A>`, we then want to be able to compose it with other instances of `M<B>` which are dependent of it. This dependency is expressed by saying that, in order to get to the instance of `M<B>` that we wish to obtain, we need a value of type `A` which will somehow come out of `M<A>`:

`bind : M<A> => (A => M<B>) => M<B>`

After having defined `unit` and `bind`, which are the bare minimum needed in order to be able to have a working monad, we can start thinking in terms of usability of our monad as a library. This usually leads to an "onion" design, with a basic core, surrounded by primitives, surrounded by combinators, templates, etc. As long as primitives, combinators, and templates all yield instances of `M`, they will still be valid input for further binding or applying the other combinators yet again. This is the fundamental principle of composability: a library should make it possible to keep nesting constructs inside each other in order to be flexible and not artificially constraining.

It is useful for some to first learn monads in terms of simple, concrete containers such as `Option` or `List`, and then move on to the more abstract ones such as the present implementation.

### Core
The core of the library, found in file `core.tsx`, contains the definition of the monad itself, `C<A>`. An instance of the monad is a function which takes as input a callback to signify completion, a continuation which will accept a value of type `A` (the data produced by the component, from now on called **output** of the component); finally, the monad returns a `JSX.Element`, which is the actually renderable component:

```
export type Cont<A> = (callback:() => void) => (_:A) => void
export type C<A> = {
  comp:(ctxt:() => Context) => (cont:Cont<A>) => JSX.Element
  ...
}
```

Using the library does not require interacting with this data type directly: that is done by invoking functions `unit` and `bind`:

```
export let unit = function<A>(x:A, key?:string, dbg?:() => string) : C<A> = ...

export let bind = function<A,B>(key:string, p:C<A>, k:((_:A)=>C<B>), className?:string, dbg?:() => string) : C<B> = ...
```

Notice that, in contrast with the definitions of `unit` and `bind` given above, we have some more parameters: since react expects a `key` in order to accelerate the reconciliation process, all generated components may specify an (optional) key. `bind` will still work if the key is passed as `undefined`, even though it is not always ideal.

Of course, we can also perform basic transformations on components' data, for example by applying a given transformation function to each output of an existing component. This effectively turns a component of type `C<A>` in a (related) component of type `C<B>`, as long as we provide a function `f:A=>B`:

```
export declare let map: <A, B>(key?: string, dbg?: () => string) => (f: (_: A) => B) => (_: C<A>) => C<B>;
```

Similarly, we can restrict the output of an existing component. This effectively turns a component of type `C<A>` in a (related) component of type `C<A>` which outputs slightly less values of type `A`, as long as we provide a predicate `p:A=>boolean`:

```
export declare let filter: <A>(key?: string, dbg?: () => string) => (p: (_: A) => boolean) => (_: C<A>) => C<A>;
```

### Primitives
Having defined the core operators is just the first step. To be able to do anything actually useful on a webpage, we have defined a series of primitives which encapsulate common HTML constructs as instances of our monad. Each primitive accepts as input the `mode` (`"view" | "edit"`) in order to instantiate the component as editable or just to show its contents.

The primitive then returns a function with, as input, the initial value of the type it manipulates (let's call it `P`) and gives as output a component of that type (that would be `C<P>`).

For example, the `number` primitive, after we have given the `mode` (and optionally the `key`), results in a function `number => C<number>`:

```
export declare let number: (mode: Mode, key?: string, dbg?: () => string) => (value: number) => C<number>;
```

The `string` primitive, after we have given the `mode` (and optionally the `key`), results in a function `string => C<string>`:

```
export declare let string: (mode: Mode, type?: StringType, key?: string, dbg?: () => string) => (value: string) => C<string>;
```

And so on. There are further primitives for `bool` (`bool => C<bool>`), `date`, `time`, and `date_time` (all three `Moment.Moment) => C<Moment.Moment>`).

### Html
The subsequent layer contains some slightly more articulated html constructs such as labels, divs, buttons, etc.




### Combinators

### Routing

### Templates

### Injecting custom react components

### Advanced

#### Building your own templates

#### Building your own combinators

# Samples


# About the authors
