# Introduction
This project makes it easier to create, compose, and re-use React controllers and containers without losing type safety, even when routing.

It does so by defining a monadic interface around React components. This interface is then used to support construction of a series of useful combinators. The library is written in TypeScript, and is provided with definition files: it can be used from both plain JavaScript and TypeScript.


## Installation
Installation is the usual `npm install monadic_react`.

## Sample usage
To use the application, create one or more components of type `C<void>`, for example:

```
let my_component : C<void> =
  string("view")("Hello world of monads!").ignore()
```

The component is then wrapped in a page for the router. Let us keep things easy and define a route which matches everything:

```
let menu_page = () : Route<{}> => ({
  url: fallback_url(),
  page: (_:{}) => my_component
})
```

The component can then be instantiated by invoking the application constructor and router:

```
<div className="component">
  {
    application("edit", window.location.href, "", Immutable.List<Route<{}>>([main_page()])))
  }
</div>
```

By working on the definition of `my_component` it is possible to create much more complex applications. For example, let us
chain two components together:

```
let my_component : C<void> =
multi_selector<number>("checkbox",x => x.toString())([1, 3, 5]).bind(`multi_selector`, n =>
  string("view")(JSON.stringify(n.toArray())).ignore())
```

In the sample above we have used the `bind` operator in order to feed the output of the multi-selector in the string renderer.

## React monad
The react monad is based on the simple idea that a non-trivial react component will eventually produce data, which is usually fed into another component.

By focusing on the flow of data generated by react components, instead of what they do on the page and how they are rendered, we focus on how components are connected together in a large network of related functionality. This removes the need for a lot of glue code which just passes information around, while preserving useful properties such as referential transparency (components can be designed fully stateless now), and type safety (components have clearly defined and typed boundaries).

For example, the `string` component will produce a string which will be fed into another component, for example a component which assembles data from various input components for later upload.

### Introduction to monads
Monads are a powerful construct tying together mathematics and informatics in an elegant way. The appeal of the highest mathematics, and the clear and useful applicability, have made monads alluring for many developers. Indeed, monads are found in, among others:
- `Promise` in the JavaScript world;
- `flatMap` in the Immutablejs library;
- `LINQ` in C#;
- the Haskell standard library;

and more. Moreover, countless tutorials are found online where people who already found out about this elegant and powerful concept try to share it with others.

At its core, a monad is a generic type `M`, that is `M` was defined along the lines of:

```type M<A> = ...```

When we define a monad in terms of `M`, then it means that we want to be able to instantiate, and use, instances of `M` without having to know anything about its structure.

The simplest operation that we need to be able to perform is creating instances of `M`. This is done with the `unit` operator, which creates an instance of `M<A>` around a value of type `A`, no matter what type `A` actually was:

`unit : A => M<A>`

Given an `M<A>`, we then want to be able to compose it with other instances of `M<B>` which are dependent of it. This dependency is expressed by saying that, in order to get to the instance of `M<B>` that we wish to obtain, we need a value of type `A` which will somehow come out of `M<A>`:

`bind : M<A> => (A => M<B>) => M<B>`

After having defined `unit` and `bind`, which are the bare minimum needed in order to be able to have a working monad, we can start thinking in terms of usability of our monad as a library. This usually leads to an "onion" design, with a basic core, surrounded by primitives, surrounded by combinators, templates, etc. As long as primitives, combinators, and templates all yield instances of `M`, they will still be valid input for further binding or applying the other combinators yet again. This is the fundamental principle of composability: a library should make it possible to keep nesting constructs inside each other in order to be flexible and not artificially constraining.

It is useful for some to first learn monads in terms of simple, concrete containers such as `Option` or `List`, and then move on to the more abstract ones such as the present implementation.

### Core
The core of the library, found in file `core.tsx`, contains the definition of the monad itself, `C<A>`. An instance of the monad is a function which takes as input a callback to signify completion, a continuation which will accept a value of type `A` (the data produced by the component, from now on called **output** of the component); finally, the monad returns a `JSX.Element`, which is the actually renderable component:

```
type Cont<A> = (callback:() => void) => (_:A) => void
type C<A> = {
  comp:(ctxt:() => Context) => (cont:Cont<A>) => JSX.Element
  ...
}
```

Using the library does not require interacting with this data type directly: that is done by invoking functions `unit` and `bind`:

```
unit = function<A>(x:A, key?:string, dbg?:() => string) : C<A> = ...

bind = function<A,B>(key:string, p:C<A>, k:((_:A)=>C<B>), className?:string, dbg?:() => string) : C<B> = ...
```

Notice that, in contrast with the definitions of `unit` and `bind` given above, we have some more parameters: since react expects a `key` in order to accelerate the reconciliation process, all generated components may specify an (optional) key. `bind` will still work if the key is passed as `undefined`, even though it is not always ideal.

Of course, we can also perform basic transformations on components' data, for example by applying a given transformation function to each output of an existing component. This effectively turns a component of type `C<A>` in a (related) component of type `C<B>`, as long as we provide a function `f:A=>B`:

```
let map: <A, B>(key?: string, dbg?: () => string) => (f: (_: A) => B) => (_: C<A>) => C<B>;
```

Similarly, we can restrict the output of an existing component. This effectively turns a component of type `C<A>` in a (related) component of type `C<A>` which outputs slightly less values of type `A`, as long as we provide a predicate `p:A=>boolean`:

```
filter: <A>(key?: string, dbg?: () => string) => (p: (_: A) => boolean) => (_: C<A>) => C<A>;
```

### Primitives
Having defined the core operators is just the first step. To be able to do anything actually useful on a webpage, we have defined a series of primitives which encapsulate common HTML constructs as instances of our monad. Each primitive accepts as input the `mode` (`"view" | "edit"`) in order to instantiate the component as editable or just to show its contents.

The primitive then returns a function with, as input, the initial value of the type it manipulates (let's call it `P`) and gives as output a component of that type (that would be `C<P>`).

For example, the `number` primitive, after we have given the `mode` (and optionally the `key`), results in a function `number => C<number>`:

```
number: (mode: Mode, key?: string, dbg?: () => string) => (value: number) => C<number>;
```

The `string` primitive, after we have given the `mode` (and optionally the `key`), results in a function `string => C<string>`:

```
string: (mode: Mode, type?: StringType, key?: string, dbg?: () => string) => (value: string) => C<string>;
```

And so on. There are further primitives for `bool` (`bool => C<bool>`), `date`, `time`, and `date_time` (all three `Moment.Moment) => C<Moment.Moment>`).

### Html
The subsequent layer contains some slightly more articulated html constructs such as labels, divs, buttons, selectors, and more. The basic components just add some tags to the page around, before, or after the html produced by another component. These constructs, which can be seen as **decorators** (or natural transformations if you are categorically inclined) take as input some basic configuration that describe the sort of decoration operation to perform, followed by the function to decorate. The function to decorate always has signature `A => C<B>`. The decorator then returns a result with the same signature, that is `A => C<B>`:

```
label<A, B>(text: string, span_before_content?: boolean, className?: string, key?: string, dbg?: () => string): (p: (_: A) => C<B>) => ((_: A) => C<B>)
h1<A, B>(text: string, className?: string, key?: string, dbg?: () => string): (p: (_: A) => C<B>) => ((_: A) => C<B>)
h2<A, B>(text: string, className?: string, key?: string, dbg?: () => string): (p: (_: A) => C<B>) => ((_: A) => C<B>)
div<A, B>(className?: string, key?: string, dbg?: () => string): (ps: Array<(_: A) => C<void>>) => (p: (_: A) => C<B>) => ((_: A) => C<B>)
overlay<A, B>(key?: string, dbg?: () => string): (ps: Array<(_: A) => C<void>>) => (p: (_: A) => C<B>) => ((_: A) => C<B>)
form<A, B>(className?: string, key?: string, dbg?: () => string): (p: (_: A) => C<B>) => ((_: A) => C<B>)
```

Buttons (and anchors) are slightly simpler in signature. The button, after receiving the configuration parameters, returns a function `A => C<A>`. This function is "interrupted" by the button: before the returned component `C<A>` will return the value of `A` that came in as input, the button must be clicked:

```
button: <A>(label: string, disabled?: boolean, key?: string, className?: string, dbg?: () => string) => (x: A) => C<A>
a: <A>(label: string, disabled?: boolean, key?: string, className?: string, dbg?: () => string) => (x: A) => C<A>
```

Other html components perform an own function. The selectors take as input the candidate items for selection, a `to_string` function which tells how to draw a selectable item, and return the selected item(s):

```
selector: <A>(type: SelectorType, to_string: (_: A) => string, key?: string, dbg?: () => string) => (items: Array<A>, selected_item?: A) => C<A>
multi_selector: <A>(type: MultiSelectorType, to_string: (_: A) => string, key?: string, dbg?: () => string) => (items: Array<A>, selected_items?: Array<A>) => C<Array<A>>
```

Finally, some html components allow the manipulation of links, files, and images (in base64).

```
image: (mode: Mode, key?: string, dbg?: () => string) => (src: string) => C<string>
link: <A>(label: string, url: string, disabled?: boolean, key?: string, dbg?: () => string) => C<void>
file: <A>(mode: Mode, label: string, url: string, disabled?: boolean, key?: string, dbg?: () => string) => C<File>
```

A special mention goes to the *rich text* component, which takes as input a string containing the (serialized) json input needed by a DraftJs rich text editor:

```
rich_text(json_state: string, mode: Mode, key?: string, dbg?: () => string): C<string>
```

### Combinators
Todo

```
export declare let repeat: <A>(p: (_: A) => C<A>, key?: string, dbg?: () => string) => (_: A) => C<A>;
export declare let any: <A, B>(ps: ((_: A) => C<B>)[], key?: string, className?: string, dbg?: () => string) => (_: A) => C<B>;
export declare let never: <A, B>(p: C<A>, key?: string) => C<B>;
export declare let all: <A>(ps: C<A>[], key?: string, dbg?: () => string) => C<A[]>;
export declare let retract: <A, B>(inb: (_: A) => B, out: (_: A) => (_: B) => A, p: (_: B) => C<B>, key?: string, dbg?: () => string) => (_: A) => C<A>;
export declare let lift_promise: <A, B>(p: (_: A) => Promise<B>, retry_strategy: RetryStrategy, key?: string, dbg?: () => string) => (_: A) => C<B>;
export declare let delay: <A>(dt: number, key?: string, dbg?: () => string) => (p: (_: A) => C<A>) => (_: A) => C<A>;
```


### Routing
Todo

### Menu template
Todo

### Form templates
Todo

### Workflow template
Todo

### Injecting custom react components
Todo

### Advanced
Todo

#### Building your own templates
Todo

#### Building your own combinators
Todo

# Samples
Todo

# About the authors
Todo